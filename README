TEAM

Nicole Saade - JHED: nsaade1
Amanda Ferber - JHED: aferber2
Meghana Karthic - JHED: mkarthi2

SPECIAL NOTE:
The Gradescope test yielding whether each team member made an equal contribution fails. The three of us have each made more than six commits. 
However, there are multiple emails associated with our Github accounts. For this reason, one of the “users”, Nicole’s github-provided email address, 
that was listed on the Github autograder test appears to have only made one commit. It should be noted Nicole has cumulatively made 16 commits across her accounts. 

DESIGN:

The overall design of this project involved the principles of dynamic binding and object oriented programming so as to maximize the usage of common functions and error handling strategies across different modularizations within our code. We started by designing each piece’s functionality: we implemented checks for legal moves, clear paths for pieces that required such a condition, and possible errors that users may make when entering a start and end position. Such code can be found in the Piece derived classes and the member functions of the Game class.. We then continued to implement functionality for more general aspects of the game and the board itself using occ, such as displaying the current pieces on display on a chess board, calculating the material point value for each player, and loading and saving the game.  In the main function, an ongoing game is represented by a while loop. Main calls functions implemented in Game to determine whether the start of each turn is in a check, checkmate or stalemate state. It then supplies the users with a series of options. The option to save a game, load a game, and make a move are all made possible by member functions of Game and Board. A major aspect of our design was the occ map of the Board class, which stored the positions that are currently occupied on the board and pointers to pieces that occupy such spaces. Whenever functions involving the rules of gameplay required access to the occupied positions on the board, Game member functions called member functions of the Board class, which allowed Game to manipulate the map or main to display the chess board. Game member functions provide for the making of legal moves by checking for move and/or capture legality and checking for a status of check, checkmate, or stalemate. Such purposes are fueled by the Piece derived classes, which provide pure virtual overridden functions pertaining to the point value, unicode representation, and legal move/capture form of each specific piece type present on the board at the start of a game. In checking for checkmate or stalemate, we first call the Game::in_check function, which tests a replica board to see if a possible movement combination is in check, and then the Game::end_of_game function which tests to see if any moves can be legally made. When checkmate/stalemate is reached or when the user types “Q,” the program terminates and utilizes the extraction operator to write the last positions of pieces out to a file optionally specified by the user at the game’s start. 

Point Value Implementation: We gave the Piece derived class a pure virtual function called point_value(). We proceeded to override this function in every Piece derived class, including that of the Mystery piece, requiring these functions to return the point values specified by Claude Shannon (1949). Then, in Game::point_value(), we looped through each existing entry of the occ map in order to take into account only the pieces that are currently in gameplay at the start of one’s turn. Depending on if it was black or white’s turn, we called point_value on the Piece object at each occupied position of only the pieces belonging to the player in command of the board. We took advantage of dynamic binding by calling [Piece]::point_value on that Piece object. Depending on the piece type it was instantiated as when the game was constructed, this function will be executed according to the implementation of a point_value function of the specified derived class. The point values returned from each of the player’s pieces currently on the board will be identified in this manner and then summed. Thus, Game::point_value returns the sum of the points of each specific piece type present on the for a certain player at the start of any given turn during gameplay. 

COMPLETENESS:

We implemented the project in its entirety as requested by the project description on the course website. To our knowledge, there is no missing or incorrect functionality. 
